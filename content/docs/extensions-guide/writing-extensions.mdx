---
title: Writing Extensions
description: Learn how to build and publish community extensions for LocalProxy
---

## LocalProxy Community Extensions Registry

This repository contains the registry of community extensions for LocalProxy.

### How it works

The `registry.json` file contains metadata about available extensions. LocalProxy clients can fetch this file to discover and install community extensions.

### Registry Format

```json
{
  "version": "1.0",
  "extensions": {
    "extension-id": {
      "name": "Extension Display Name",
      "version": "1.0.0",
      "url": "https://raw.githubusercontent.com/localproxy-community/extension-id/main/index.js"
    }
  }
}
```

## Adding Your Extension

To add your extension to the registry:

1. Create a repository under the `localproxy-community` organization
2. Add your extension code as `index.js` in the `main` branch
3. Submit a PR to the registry repository updating `registry.json`

## Extension Requirements

- Extensions must be written in JavaScript (not TypeScript)
- Extensions must export the required interface: `metadata`, `urlPatterns`, `onRequest`, `onResponseStreamTransform`
- Extensions should be self-contained and not require external dependencies

## Extension Interface

Your `index.js` must export the following symbols:

```js
export const metadata = {
  id: "extension-id",
  name: "Extension Display Name",
  version: "1.0.0",
  description: "What this extension does",
  author: "Your Name",
};

// One or more URL matchers (strings or regex-like strings)
export const urlPatterns = [
  "https://api.example.com/v1/*",
  "https://*.example.net/*",
];

// Optional: mutate outgoing request before it is sent
export async function onRequest(request) {
  // request: { method, url, headers: Record<string,string>, body: Uint8Array | null }
  // Return the (possibly) modified request or nothing to keep as-is
  request.headers["x-localproxy-ext"] = "extension-id";
  return request;
}

// Optional: transform streaming response chunks on-the-fly
export async function onResponseStreamTransform(ctx) {
  // ctx: { url, headers: Record<string,string>, readable: ReadableStream<Uint8Array> }
  // Return either the same ctx.readable or a new ReadableStream
  const reader = ctx.readable.getReader();
  const stream = new ReadableStream({
    async pull(controller) {
      const { value, done } = await reader.read();
      if (done) {
        controller.close();
        return;
      }
      // Example: pass-through unchanged
      controller.enqueue(value);
    },
  });
  return { ...ctx, readable: stream };
}
```

## Minimal Example

Below is a minimal `index.js` you can copy as a starting point:

```js
export const metadata = {
  id: "example-hello",
  name: "Hello Header Injector",
  version: "1.0.0",
  description: "Adds an X-Hello header to matched requests",
  author: "localproxy-community",
};

export const urlPatterns = ["https://api.example.com/*"]; // match any path under api.example.com

export async function onRequest(request) {
  request.headers["x-hello"] = "world";
  return request;
}

export async function onResponseStreamTransform(ctx) {
  // No-op pass-through of the response stream
  return ctx;
}
```

## Publishing Checklist

- [ ] Repo created under `localproxy-community/<your-extension-id>`
- [ ] `index.js` in the root of the `main` branch
- [ ] `metadata.id` matches the repository slug
- [ ] Tested locally with LocalProxy
- [ ] PR opened to add your extension entry to `registry.json`

## Troubleshooting

- Ensure your extension is plain JavaScript (no TypeScript syntax)
- Avoid importing external dependencies; keep everything self-contained
- Validate your `urlPatterns` actually match the target endpoints
- Log sparingly and avoid leaking secrets in headers or URLs
